<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebXR VR Shooter — Fixed Version</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:system-ui,Segoe UI,Roboto,Arial;overflow:hidden}
    #info{position:fixed;left:12px;top:12px;z-index:20;background:rgba(0,0,0,0.45);padding:8px 12px;border-radius:8px}
  </style>
</head>
<body>
  <div id="info">WebXR Shooter — Score: 0</div>
  <script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js';
  import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/webxr/VRButton.js';

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
  light.position.set(0,50,0);
  scene.add(light);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(-10,20,10);
  scene.add(dirLight);

  const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x2d8b4f}));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true;
  scene.add(ground);

  // === RIG SETUP ===
  const rig = new THREE.Group();
  rig.position.set(0,0,5);
  scene.add(rig);

  // Camera and controllers inside rig
  rig.add(camera);

  const controller1 = renderer.xr.getController(0);
  const controller2 = renderer.xr.getController(1);
  rig.add(controller1);
  rig.add(controller2);

  const controllerModel = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.04,0.2,8), new THREE.MeshStandardMaterial({color:0x333}));
  controllerModel.rotation.x = -Math.PI/2;
  controller1.add(controllerModel.clone());
  controller2.add(controllerModel.clone());

  // === BULLETS ===
  const bullets = [];
  const bulletGeo = new THREE.SphereGeometry(0.08,8,8);
  const bulletMat = new THREE.MeshBasicMaterial({color:0xffff00});
  function shoot(controller){
    const b = new THREE.Mesh(bulletGeo, bulletMat);
    const pos = new THREE.Vector3();
    controller.getWorldPosition(pos);
    b.position.copy(pos);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(controller.quaternion).normalize();
    scene.add(b);
    bullets.push({mesh:b, dir:dir, life:3});
  }
  controller1.addEventListener('selectstart', function(){shoot(this);});
  controller2.addEventListener('selectstart', function(){shoot(this);});

  // === ENEMIES ===
  const enemies = [];
  const enemyMat = new THREE.MeshStandardMaterial({color:0xff4444});
  function spawnEnemy(x,z){
    const e = new THREE.Mesh(new THREE.SphereGeometry(0.7,12,12), enemyMat);
    e.position.set(x,0.7,z);
    scene.add(e);
    enemies.push(e);
  }
  for(let i=0;i<15;i++) spawnEnemy((Math.random()-0.5)*60,(Math.random()-0.5)*60);
  setInterval(()=>{ if(enemies.length<30) spawnEnemy((Math.random()-0.5)*60,(Math.random()-0.5)*60); }, 5000);

  // === COLLECTIBLES ===
  const collectibles = [];
  const coinMat = new THREE.MeshStandardMaterial({emissive:0xffd15c, metalness:0.5, roughness:0.3});
  function spawnCoin(x,y,z){
    const c = new THREE.Mesh(new THREE.SphereGeometry(0.35,12,12), coinMat);
    c.position.set(x,y,z);
    scene.add(c);
    collectibles.push(c);
  }
  for(let i=0;i<18;i++) spawnCoin((Math.random()-0.5)*60,0.5+Math.random()*2,(Math.random()-0.5)*60);

  // === HUD ===
  const infoEl = document.getElementById('info');
  let score = 0;
  function updateHUD(){ infoEl.innerHTML = `WebXR Shooter — Score: ${score}`; }

  // === VR MOVEMENT ===
  function updateVRMovement(dt){
    const speed = 3;
    [controller1, controller2].forEach(controller=>{
      const gp = controller.gamepad;
      if(gp && gp.axes.length >= 4){
        const x = gp.axes[2] || 0;
        const y = gp.axes[3] || 0;
        if(Math.abs(x)>0.1 || Math.abs(y)>0.1){
          const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); forward.y=0; forward.normalize();
          const right = new THREE.Vector3().crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();
          const move = new THREE.Vector3();
          move.addScaledVector(right,x*speed*dt);
          move.addScaledVector(forward,y*speed*dt);
          rig.position.add(move);
        }
      }
    });
  }

  // === ANIMATION LOOP ===
  const clock = new THREE.Clock();
  function animate(){
    const dt = Math.min(0.05, clock.getDelta());

    if(renderer.xr.isPresenting){ updateVRMovement(dt); }

    // bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b = bullets[i]; b.mesh.position.addScaledVector(b.dir,dt*25); b.life-=dt;
      if(b.life<=0){ scene.remove(b.mesh); bullets.splice(i,1); continue; }
      for(let j=enemies.length-1;j>=0;j--){
        const en = enemies[j];
        if(b.mesh.position.distanceTo(en.position)<0.9){ scene.remove(en); enemies.splice(j,1); scene.remove(b.mesh); bullets.splice(i,1); score+=10; updateHUD(); break; }
      }
      for(let k=collectibles.length-1;k>=0;k--){
        const coin = collectibles[k];
        if(b.mesh.position.distanceTo(coin.position)<0.6){ scene.remove(coin); collectibles.splice(k,1); scene.remove(b.mesh); bullets.splice(i,1); score+=3; updateHUD(); break; }
      }
    }

    // enemies move
    for(const en of enemies){
      const dir = new THREE.Vector3().subVectors(rig.position,en.position); dir.y=0; if(dir.length()>0.2){ dir.normalize(); en.position.addScaledVector(dir, dt*0.8); }
    }

    // coins float
    const t = performance.now()/500;
    for(const c of collectibles) c.position.y += Math.sin(t + c.position.x*0.1)*0.002;

    renderer.render(scene,camera);
  }
  renderer.setAnimationLoop(animate);

  // resize
  window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  updateHUD();
  </script>
</body>
</html>
